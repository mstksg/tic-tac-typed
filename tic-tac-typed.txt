-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/tic-tac-typed#readme</a>
@package tic-tac-typed
@version 0.1.0.0

module Data.Type.Sel

-- | A <tt><a>Sel</a> n as a</tt> is an index into a list <tt>as</tt> that
--   the <tt>n</tt>th index is <tt>a</tt>.
data Sel :: N -> [k] -> k -> Type
[SelZ] :: Sel  'Z (a : as) a
[SelS] :: Sel n as a -> Sel ( 'S n) (b : as) a
type InBounds n = Found (TyPP (Sel n))
type OutOfBounds n = Not (InBounds n)

-- | Represents a 2-d <a>Sel</a>.
data Coord :: (N, N) -> [[k]] -> k -> Type
[:$:] :: Sel i xss xs -> Sel j xs x -> Coord '(i, j) xss x
instance Data.Singletons.Internal.SingI n => Data.Type.Predicate.Decidable (Data.Type.Sel.InBounds n)

module TTT.Core
data Piece
PX :: Piece
PO :: Piece
type SPiece = (Sing :: Piece -> Type)
data Result
ResCats :: Result
ResWin :: Piece -> Result
type SResult = (Sing :: Result -> Type)
type Board = [[Maybe Piece]]

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
altP :: Piece -> Piece
type family AltP (a_ayqi :: Piece) :: Piece
sAltP :: forall (t_ayDa :: Piece). Sing t_ayDa -> Sing (Apply AltPSym0 t_ayDa :: Piece)
lines :: [[a_ax8F]] -> [[a_ax8F]]
type family Lines (a_ayqf :: [[a_ax8F]]) :: [[a_ax8F]]
sLines :: forall a_ax8F (t_ayD8 :: [[a_ax8F]]). Sing t_ayD8 -> Sing (Apply LinesSym0 t_ayD8 :: [[a_ax8F]])
emptyBoard :: Board
type family EmptyBoard :: [[Maybe Piece]]
sEmptyBoard :: Sing (EmptyBoardSym0 :: [[Maybe Piece]])
type family PlaceBoard (a_aNE6 :: N) (a_aNE7 :: N) (a_aNE8 :: Piece) (a_aNE9 :: [[Maybe Piece]]) :: [[Maybe Piece]]
sPlaceBoard :: forall (t_aNEk :: N) (t_aNEl :: N) (t_aNEm :: Piece) (t_aNEn :: [[Maybe Piece]]). Sing t_aNEk -> Sing t_aNEl -> Sing t_aNEm -> Sing t_aNEn -> Sing (Apply (Apply (Apply (Apply PlaceBoardSym0 t_aNEk) t_aNEl) t_aNEm) t_aNEn :: [[Maybe Piece]])

-- | Convert a parameterized predicate into a predicate on the parameter.
--   
--   A <tt><a>Found</a> p</tt> is a predicate on <tt>p :: <a>ParamPred</a>
--   k v</tt> that tests a <tt>k</tt> for the fact that there exists a
--   <tt>v</tt> where <tt><a>ParamPred</a> k v</tt> is satisfied.
--   
--   Intended as the basic interface for <a>ParamPred</a>, since it turns a
--   <a>ParamPred</a> into a normal <a>Predicate</a>, which can have
--   <a>Decidable</a> and <a>Provable</a> instances.
--   
--   For some context, an instance of <tt><a>Provable</a> (<a>Found</a>
--   P)</tt>, where <tt>P :: <a>ParamPred</a> k v</tt>, means that for any
--   input <tt>x :: k</tt>, we can always find a <tt>y :: v</tt> such that
--   we have <tt>P x @@ y</tt>.
--   
--   In the language of quantifiers, it means that forall <tt>x :: k</tt>,
--   there exists a <tt>y :: v</tt> such that <tt>P x @@ y</tt>.
--   
--   For an instance of <tt><a>Decidable</a> (<a>Found</a> P)</tt>, it
--   means that for all <tt>x :: k</tt>, we can prove or disprove the fact
--   that there exists a <tt>y :: v</tt> such that <tt>P x @@ y</tt>.
data Found (a :: ParamPred k v) (b :: TyFun k Type) :: forall v k. () => ParamPred k v -> TyFun k Type -> Type

-- | Predicate that a board is won by a given player
--   
--   <pre>
--   Winner :: ParamPred Board Piece
--   </pre>
type Winner = LinesSym0 `PPMap` AnyMatch [] Victory

-- | Predicate that all spots have been played (cats game).
--   
--   <pre>
--   <a>Cats</a> :: <a>Predicate</a> <a>Board</a>
--   </pre>
type Cats = All [] (All [] IsJust)

-- | Witness that a game is in a specific mode.
data GameOverWit :: Board -> Result -> Type
[GOVictory] :: (Winner b @@ p) -> GameOverWit b ( 'ResWin p)
[GOCats] :: (Not (Found Winner) @@ b) -> (Cats @@ b) -> GameOverWit b  'ResCats

-- | Parameterized predicate that a game is won by a player (or cats) for
--   for a given board.
--   
--   <pre>
--   GameOver :: ParamPred Board Result
--   </pre>
type GameOver = TyPP GameOverWit

-- | Current board and currently expected player.
--   
--   Can only be constructed by appending valid moves onto a known valid
--   game state.
data GameState :: Piece -> Board -> Type
[GSStart] :: GameState  'PX EmptyBoard
[GSUpdate] :: (InPlay @@ b1) -> Update p b1 b2 -> GameState p b1 -> GameState (AltP p) b2

-- | Represents a legal update to a board (in-bounds, and does not
--   overwrite a played piece)
data Update :: Piece -> Board -> Board -> Type
[Update] :: forall i j p b. () => Coord '(i, j) b  'Nothing -> Update p b (PlaceBoard i j p b)

-- | Represents a 2-d <a>Sel</a>.
data Coord :: (N, N) -> [[k]] -> k -> Type
[:$:] :: Sel i xss xs -> Sel j xs x -> Coord '(i, j) xss x

-- | A predicate that a game is still in play
type InPlay = Not (Found GameOver)

-- | The empty board is in-play.
startInPlay :: InPlay @@ EmptyBoard

-- | Type-safe "play".
play :: forall b i j p. () => (InPlay @@ b) -> Coord '(i, j) b  'Nothing -> GameState p b -> GameState (AltP p) (PlaceBoard i j p b)

-- | Potential results of <tt>pick</tt>: A verified move, or one of many
--   failures (with proof of failures)
data Pick :: (N, N, Board) -> Type
[PickValid] :: Coord '(i, j) b  'Nothing -> Pick '(i, j, b)
[PickPlayed] :: Coord '(i, j) b ( 'Just p) -> Sing p -> Pick '(i, j, b)
[PickOoBX] :: (OutOfBounds i @@ b) -> Pick '(i, j, b)
[PickOoBY] :: Sel i b row -> (OutOfBounds j @@ row) -> Pick '(i, j, b)
data ResWinSym0 :: (~>) Piece Result
type ResWinSym1 (t6989586621679142109 :: Piece) = ResWin t6989586621679142109
type ResCatsSym0 = ResCats
type BoardSym0 = Board
data AltPSym0 :: (~>) Piece Piece
type AltPSym1 (a6989586621679142118 :: Piece) = AltP a6989586621679142118
data LinesSym0 :: forall a6989586621679137181. (~>) [[a6989586621679137181]] [[a6989586621679137181]]
type LinesSym1 (a6989586621679142115 :: [[a6989586621679137181]]) = Lines a6989586621679142115
type EmptyBoardSym0 = EmptyBoard
data PlaceBoardSym0 :: (~>) N ((~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])))
data PlaceBoardSym1 (a6989586621679200634 :: N) :: (~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]]))
data PlaceBoardSym2 (a6989586621679200634 :: N) (a6989586621679200635 :: N) :: (~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])
data PlaceBoardSym3 (a6989586621679200634 :: N) (a6989586621679200635 :: N) (a6989586621679200636 :: Piece) :: (~>) [[Maybe Piece]] [[Maybe Piece]]
type PlaceBoardSym4 (a6989586621679200634 :: N) (a6989586621679200635 :: N) (a6989586621679200636 :: Piece) (a6989586621679200637 :: [[Maybe Piece]]) = PlaceBoard a6989586621679200634 a6989586621679200635 a6989586621679200636 a6989586621679200637
instance Data.Type.Predicate.Provable (Data.Type.Predicate.TyPred TTT.Core.Pick)
instance Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found TTT.Core.GameOver)
instance Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found TTT.Core.Victory)
instance Data.Type.Predicate.Auto.Auto (Data.Type.Predicate.Not (Data.Type.Predicate.Param.Found TTT.Core.Victory)) ('GHC.Maybe.Nothing : as)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.PlaceBoardSym0
instance Data.Singletons.Internal.SingI TTT.Core.PlaceBoardSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym1 a6989586621679200634)
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym1 d)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym2 a6989586621679200635 a6989586621679200634)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym2 d1 d2)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym3 a6989586621679200636 a6989586621679200635 a6989586621679200634)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2, Data.Singletons.Internal.SingI d3) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym3 d1 d2 d3)
instance GHC.Classes.Eq TTT.Core.Result
instance GHC.Show.Show TTT.Core.Result
instance GHC.Classes.Eq TTT.Core.Piece
instance GHC.Show.Show TTT.Core.Piece
instance GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.ShowSing.ShowSing TTT.Core.Piece => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.Result
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679142897Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.Result
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679142897Sym1 a6989586621679142894)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679142897Sym2 a6989586621679142895 a6989586621679142894)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679142875Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679142875Sym1 a6989586621679142872)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679142875Sym2 a6989586621679142873 a6989586621679142872)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.AltPSym0
instance Data.Singletons.Internal.SingI TTT.Core.AltPSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.LinesSym0
instance Data.Singletons.Internal.SingI TTT.Core.LinesSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.DiagonalSym0
instance Data.Singletons.Internal.SingI TTT.Core.DiagonalSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ResWinSym0
instance Data.Singletons.Internal.SingI TTT.Core.ResWinSym0
instance Data.Singletons.Internal.SingKind TTT.Core.Result
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece => Data.Singletons.Prelude.Show.SShow TTT.Core.Result
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece => Data.Singletons.Prelude.Eq.SEq TTT.Core.Result
instance Data.Singletons.Decide.SDecide TTT.Core.Piece => Data.Singletons.Decide.SDecide TTT.Core.Result
instance Data.Singletons.Internal.SingI 'TTT.Core.ResCats
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('TTT.Core.ResWin n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'TTT.Core.ResWin)
instance Data.Singletons.Internal.SingKind TTT.Core.Piece
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece
instance Data.Singletons.Decide.SDecide TTT.Core.Piece
instance Data.Singletons.Internal.SingI 'TTT.Core.PX
instance Data.Singletons.Internal.SingI 'TTT.Core.PO

module TTT.Controller
type Controller m p = forall b. CContext p b -> m (Maybe (Move @@ b))
type Move = Found AvailableSpot
data CContext p b
CC :: Sing b -> (InPlay @@ b) -> GameState p b -> Sing p -> CContext p b
[_ccBoard] :: CContext p b -> Sing b
[_ccInPlay] :: CContext p b -> InPlay @@ b
[_ccGameState] :: CContext p b -> GameState p b
[_ccPlayer] :: CContext p b -> Sing p

-- | Picks the first valid move in the given list
priorityController :: Applicative m => [(N, N)] -> Controller m p

-- | Picks a random move
randomController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Controller m p
validMoves :: Sing b -> Map (N, N) (Move @@ b)
shuffledValidMoves :: PrimMonad m => Sing b -> Gen (PrimState m) -> m [((N, N), Move @@ b)]

-- | Return a controller that, some percentage of the time, picks randomly
--   instead.
faulty :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Double -> Controller m p -> Controller m p

module TTT.Controller.Minimax

-- | This minimax implementation is "verified" in the sense that it cannot
--   make any illegal moves. We sort of get this "for free". It is also
--   verified that we will rank and sort the pieces correctly (assuming the
--   Ord instance is sound) depending on who is playing.
minimaxController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p

-- | This minimax implementation is "more verified" than the original one.
--   In addition to the verifications of the original one, we verify that
--   the search algorithm doesn't go further than the number of steps, and
--   also that at each step we are being consistent with the board and
--   possible moves.
--   
--   However, it is not a "verified AI" in that it can still make the wrong
--   choice in the end. The only thing verified really is that it
--   interprets the information it sees correctly.
minimaxController' :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p
newtype RankRes (p :: Piece)
RR :: Maybe Result -> RankRes
[getRR] :: RankRes -> Maybe Result
instance GHC.Classes.Eq (TTT.Controller.Minimax.RankRes p)
instance GHC.Show.Show (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Internal.SingI p => GHC.Classes.Ord (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Decide.SDecide k => Data.GADT.Compare.GEq Data.Singletons.Internal.Sing

module TTT.Controller.Console

-- | Will never allow any invalid moves.
consoleController :: MonadIO m => Controller m p
displayBoard :: Board -> String
