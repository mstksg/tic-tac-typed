-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/tic-tac-typed#readme</a>
@package tic-tac-typed
@version 0.1.0.0

module Data.Type.Nat
data N
Z :: N
S :: N -> N
type SN = (Sing :: N -> Type)

-- | The singleton kind-indexed data family.
addN :: N -> N -> N
sAddN :: forall (t_anea :: N) (t_aneb :: N). Sing t_anea -> Sing t_aneb -> Sing (Apply (Apply AddNSym0 t_anea) t_aneb :: N)
data LT :: N -> N -> Type
[LTZ] :: LT  'Z n
[LTS] :: LT n m -> LT ( 'S n) ( 'S m)
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679093404 :: N) = S t6989586621679093404
data AddNSym0 :: (~>) N ((~>) N N)
data AddNSym1 (a6989586621679093406 :: N) :: (~>) N N
type AddNSym2 (a6989586621679093406 :: N) (a6989586621679093407 :: N) = AddN a6989586621679093406 a6989586621679093407
instance GHC.Classes.Ord Data.Type.Nat.N
instance GHC.Classes.Eq Data.Type.Nat.N
instance GHC.Show.Show Data.Type.Nat.N
instance Data.Singletons.Prelude.Eq.PEq Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.Compare_6989586621679099072Sym0
instance Data.Singletons.Prelude.Ord.POrd Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.Compare_6989586621679099072Sym1 a6989586621679099070)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.ShowsPrec_6989586621679097175Sym0
instance Data.Singletons.Prelude.Show.PShow Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.ShowsPrec_6989586621679097175Sym1 a6989586621679097172)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.ShowsPrec_6989586621679097175Sym2 a6989586621679097173 a6989586621679097172)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.AddNSym1 a6989586621679093406)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.AddNSym0
instance Data.Singletons.Internal.SingI Data.Type.Nat.AddNSym0
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Nat.AddNSym1 d)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.SSym0
instance Data.Singletons.Internal.SingI Data.Type.Nat.SSym0
instance Data.Singletons.Internal.SingKind Data.Type.Nat.N
instance Data.Singletons.Prelude.Show.SShow Data.Type.Nat.N => Data.Singletons.Prelude.Show.SShow Data.Type.Nat.N
instance Data.Singletons.Prelude.Ord.SOrd Data.Type.Nat.N => Data.Singletons.Prelude.Ord.SOrd Data.Type.Nat.N
instance Data.Singletons.Prelude.Eq.SEq Data.Type.Nat.N => Data.Singletons.Prelude.Eq.SEq Data.Type.Nat.N
instance Data.Singletons.Decide.SDecide Data.Type.Nat.N => Data.Singletons.Decide.SDecide Data.Type.Nat.N
instance Data.Singletons.ShowSing.ShowSing Data.Type.Nat.N => Data.Singletons.ShowSing.ShowSing Data.Type.Nat.N
instance Data.Singletons.ShowSing.ShowSing Data.Type.Nat.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Internal.SingI 'Data.Type.Nat.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Data.Type.Nat.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Data.Type.Nat.S)

module Data.Type.Sel

-- | A <tt><a>Sel</a> n as a</tt> is an index into a list <tt>as</tt> that
--   the <tt>n</tt>th index is <tt>a</tt>.
data Sel :: N -> [k] -> k -> Type
[SelZ] :: Sel  'Z (a : as) a
[SelS] :: Sel n as a -> Sel ( 'S n) (b : as) a
mapIx :: N -> (a_aLRR -> a_aLRR) -> [a_aLRR] -> [a_aLRR]
sMapIx :: forall a_aLRR (t_aLT9 :: N) (t_aLTa :: (~>) a_aLRR a_aLRR) (t_aLTb :: [a_aLRR]). Sing t_aLT9 -> Sing t_aLTa -> Sing t_aLTb -> Sing (Apply (Apply (Apply MapIxSym0 t_aLT9) t_aLTa) t_aLTb :: [a_aLRR])
setIx :: N -> a_aLRQ -> [a_aLRQ] -> [a_aLRQ]
sSetIx :: forall a_aLRQ (t_aLTf :: N) (t_aLTg :: a_aLRQ) (t_aLTh :: [a_aLRQ]). Sing t_aLTf -> Sing t_aLTg -> Sing t_aLTh -> Sing (Apply (Apply (Apply SetIxSym0 t_aLTf) t_aLTg) t_aLTh :: [a_aLRQ])
overSel :: forall k n (as :: [k]) (a :: k) (f :: k ~> k). () => Sel n as a -> Sing f -> Sing as -> Sing (MapIx n f as)
setSel :: forall k n (as :: [k]) (a :: k) (b :: k). () => Sel n as a -> Sing b -> Sing as -> Sing (SetIx n b as)
listSel :: forall k n (as :: [k]). () => Sing n -> Sing as -> Decision (Σ k (TyCon (Sel n as)))
type OutOfBounds n (as :: [k]) = Refuted (Σ k (TyCon (Sel n as)))
mapIx_proof :: forall n as a f. () => Sel n as a -> Sing as -> Sel n (MapIx n f as) (f @@ a)
setIx_proof :: forall n as a b. () => Sel n as a -> Sing as -> Sel n (SetIx n b as) b
data MapIxSym0 :: forall a6989586621679193799. (~>) N ((~>) ((~>) a6989586621679193799 a6989586621679193799) ((~>) [a6989586621679193799] [a6989586621679193799]))
data MapIxSym1 (a6989586621679193855 :: N) :: forall a6989586621679193799. (~>) ((~>) a6989586621679193799 a6989586621679193799) ((~>) [a6989586621679193799] [a6989586621679193799])
data MapIxSym2 (a6989586621679193855 :: N) (a6989586621679193856 :: (~>) a6989586621679193799 a6989586621679193799) :: (~>) [a6989586621679193799] [a6989586621679193799]
type MapIxSym3 (a6989586621679193855 :: N) (a6989586621679193856 :: (~>) a6989586621679193799 a6989586621679193799) (a6989586621679193857 :: [a6989586621679193799]) = MapIx a6989586621679193855 a6989586621679193856 a6989586621679193857
data SetIxSym0 :: forall a6989586621679193798. (~>) N ((~>) a6989586621679193798 ((~>) [a6989586621679193798] [a6989586621679193798]))
data SetIxSym1 (a6989586621679193868 :: N) :: forall a6989586621679193798. (~>) a6989586621679193798 ((~>) [a6989586621679193798] [a6989586621679193798])
data SetIxSym2 (a6989586621679193868 :: N) (a6989586621679193869 :: a6989586621679193798) :: (~>) [a6989586621679193798] [a6989586621679193798]
type SetIxSym3 (a6989586621679193868 :: N) (a6989586621679193869 :: a6989586621679193798) (a6989586621679193870 :: [a6989586621679193798]) = SetIx a6989586621679193868 a6989586621679193869 a6989586621679193870
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Sel.SetIxSym0
instance Data.Singletons.Internal.SingI Data.Type.Sel.SetIxSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.SetIxSym1 a6989586621679193868 a6989586621679193798)
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Sel.SetIxSym1 d a)
instance forall a6989586621679193798 (a6989586621679193869 :: Data.Type.Nat.N) (a6989586621679193868 :: a6989586621679193798). Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.SetIxSym2 a6989586621679193869 a6989586621679193868)
instance forall a (d1 :: Data.Type.Nat.N) (d2 :: a). (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (Data.Type.Sel.SetIxSym2 d1 d2)
instance forall a6989586621679193799 (a6989586621679193856 :: Data.Type.Nat.N) (a6989586621679193855 :: a6989586621679193799 Data.Singletons.Internal.~> a6989586621679193799). Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.MapIxSym2 a6989586621679193856 a6989586621679193855)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.MapIxSym1 a6989586621679193855 a6989586621679193799)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Sel.MapIxSym0
instance Data.Singletons.Internal.SingI Data.Type.Sel.MapIxSym0
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Sel.MapIxSym1 d a)
instance forall a (d1 :: Data.Type.Nat.N) (d2 :: a Data.Singletons.Internal.~> a). (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (Data.Type.Sel.MapIxSym2 d1 d2)

module TTT.Core
data Piece
PX :: Piece
PO :: Piece
type SPiece = (Sing :: Piece -> Type)
data GameOver
GOCats :: GameOver
GOWin :: Piece -> GameOver
type SGameOver = (Sing :: GameOver -> Type)
type Board = [[Maybe Piece]]

-- | The singleton kind-indexed data family.
altP :: Piece -> Piece
sAltP :: forall (t_aQCq :: Piece). Sing t_aQCq -> Sing (Apply AltPSym0 t_aQCq :: Piece)
lines :: [[a_aPT5]] -> [[a_aPT5]]
sLines :: forall a_aPT5 (t_aQCo :: [[a_aPT5]]). Sing t_aQCo -> Sing (Apply LinesSym0 t_aQCo :: [[a_aPT5]])
emptyBoard :: Board
sEmptyBoard :: Sing (EmptyBoardSym0 :: [[Maybe Piece]])
placeBoard :: N -> N -> Piece -> Board -> Board
sPlaceBoard :: forall (t_aQCe :: N) (t_aQCf :: N) (t_aQCg :: Piece) (t_aQCh :: [[Maybe Piece]]). Sing t_aQCe -> Sing t_aQCf -> Sing t_aQCg -> Sing t_aQCh -> Sing (Apply (Apply (Apply (Apply PlaceBoardSym0 t_aQCe) t_aQCf) t_aQCg) t_aQCh :: [[Maybe Piece]])

-- | Predicate that a board is won by a given player
data BoardWonBy :: Board -> Predicate Piece

-- | Predicate that a board has some winnner
type HasWinner = Found Piece BoardWonBy

-- | Predicate that all spots have been played (cats game).
--   
--   <pre>
--   <a>Cats</a> :: <a>Predicate</a> <a>Board</a>
--   </pre>
type Cats = All [] (All [] (Any Maybe Evident))

-- | Witness that a game is in a specific mode.
--   
--   Generate using <a>Taken</a> for <a>SomeGameMode</a>.
data GameMode :: Board -> Maybe GameOver -> Type
[GMVictory] :: BoardWonBy b @@ p -> GameMode b ( 'Just ( 'GOWin p))
[GMCats] :: Not HasWinner @@ b -> Cats @@ b -> GameMode b ( 'Just  'GOCats)
[GMInPlay] :: Not HasWinner @@ b -> Not Cats @@ b -> GameMode b  'Nothing

-- | Predicate that a board has a given game mode.
--   
--   Usable with is <a>Taken</a> instance.
type SomeGameMode = Found (Maybe GameOver) GameModeFor

-- | Current board and currently expected player.
--   
--   Can only be constructed by appending valid moves onto a known valid
--   game state.
data GameState :: Piece -> Board -> Type
[GSStart] :: GameState  'PX EmptyBoard
[GSUpdate] :: InPlay b1 -> Update ij p b1 b2 -> GameState p b1 -> GameState (AltP p) b2

-- | Represents a legal update to a board (in-bounds, and does not
--   overwrite a played piece)
data Update :: (N, N) -> Piece -> Board -> Board -> Type
[Update] :: Coord b  'Nothing '(i, j) -> Sing p -> Update '(i, j) p b (PlaceBoard i j p b)

-- | Represents a board and coordinate with the current item at position on
--   the board.
data Coord :: Board -> Maybe Piece -> (N, N) -> Type
[Coord] :: Sel i b row -> Sel j row p -> Coord b p '(i, j)
type InPlay b = GameMode b  'Nothing

-- | The empty board is in-play.
startInPlay :: InPlay EmptyBoard

-- | Type-safe "play".
play :: forall b i j row p. () => InPlay b -> Sel i b row -> Sel j row  'Nothing -> Sing p -> GameState p b -> GameState (AltP p) (PlaceBoard i j p b)

-- | Potential results of <a>pick</a>: A verified move, or one of many
--   failures (with proof of failures)
data Pick :: N -> N -> Board -> Type
[PickValid] :: Sel i b row -> Sel j row  'Nothing -> Pick i j b
[PickPlayed] :: Sel i b row -> Sel j row ( 'Just p) -> Sing p -> Pick i j b
[PickOoBX] :: OutOfBounds i b -> Pick i j b
[PickOoBY] :: Sel i b row -> OutOfBounds j row -> Pick i j b

-- | Validate a pick from given coordinates on a board
pick :: Sing i -> Sing j -> Sing b -> Pick i j b
data GOWinSym0 :: (~>) Piece GameOver
type GOWinSym1 (t6989586621679211973 :: Piece) = GOWin t6989586621679211973
type GOCatsSym0 = GOCats
type BoardSym0 = Board
data AltPSym0 :: (~>) Piece Piece
type AltPSym1 (a6989586621679211996 :: Piece) = AltP a6989586621679211996
data LinesSym0 :: forall a6989586621679209251. (~>) [[a6989586621679209251]] [[a6989586621679209251]]
type LinesSym1 (a6989586621679211993 :: [[a6989586621679209251]]) = Lines a6989586621679211993
type EmptyBoardSym0 = EmptyBoard
data PlaceBoardSym0 :: (~>) N ((~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])))
data PlaceBoardSym1 (a6989586621679211975 :: N) :: (~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]]))
data PlaceBoardSym2 (a6989586621679211975 :: N) (a6989586621679211976 :: N) :: (~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])
data PlaceBoardSym3 (a6989586621679211975 :: N) (a6989586621679211976 :: N) (a6989586621679211977 :: Piece) :: (~>) [[Maybe Piece]] [[Maybe Piece]]
type PlaceBoardSym4 (a6989586621679211975 :: N) (a6989586621679211976 :: N) (a6989586621679211977 :: Piece) (a6989586621679211978 :: [[Maybe Piece]]) = PlaceBoard a6989586621679211975 a6989586621679211976 a6989586621679211977 a6989586621679211978
instance GHC.Classes.Eq TTT.Core.GameOver
instance GHC.Show.Show TTT.Core.GameOver
instance GHC.Classes.Eq TTT.Core.Piece
instance GHC.Show.Show TTT.Core.Piece
instance Data.Type.Predicate.Decide TTT.Core.SomeGameMode
instance Data.Type.Predicate.Taken TTT.Core.SomeGameMode
instance Data.Type.Predicate.Decide TTT.Core.SomeVictory
instance Data.Type.Predicate.Decide (TTT.Core.Found TTT.Core.Piece TTT.Core.BoardWonBy)
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.GameOver
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679212035Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.GameOver
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679212035Sym1 a6989586621679212032)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679212035Sym2 a6989586621679212033 a6989586621679212032)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679212013Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679212013Sym1 a6989586621679212010)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679212013Sym2 a6989586621679212011 a6989586621679212010)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.AltPSym0
instance Data.Singletons.Internal.SingI TTT.Core.AltPSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.LinesSym0
instance Data.Singletons.Internal.SingI TTT.Core.LinesSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.DiagonalSym0
instance Data.Singletons.Internal.SingI TTT.Core.DiagonalSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.PlaceBoardSym0
instance Data.Singletons.Internal.SingI TTT.Core.PlaceBoardSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym1 a6989586621679211975)
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym1 d)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym2 a6989586621679211976 a6989586621679211975)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym2 d1 d2)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym3 a6989586621679211977 a6989586621679211976 a6989586621679211975)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2, Data.Singletons.Internal.SingI d3) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym3 d1 d2 d3)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.GOWinSym0
instance Data.Singletons.Internal.SingI TTT.Core.GOWinSym0
instance Data.Singletons.Internal.SingKind TTT.Core.GameOver
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece => Data.Singletons.Prelude.Show.SShow TTT.Core.GameOver
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece => Data.Singletons.Prelude.Eq.SEq TTT.Core.GameOver
instance Data.Singletons.Decide.SDecide TTT.Core.Piece => Data.Singletons.Decide.SDecide TTT.Core.GameOver
instance Data.Singletons.ShowSing.ShowSing TTT.Core.Piece => Data.Singletons.ShowSing.ShowSing TTT.Core.GameOver
instance Data.Singletons.ShowSing.ShowSing TTT.Core.Piece => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Internal.SingI 'TTT.Core.GOCats
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('TTT.Core.GOWin n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'TTT.Core.GOWin)
instance Data.Singletons.Internal.SingKind TTT.Core.Piece
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece
instance Data.Singletons.Decide.SDecide TTT.Core.Piece
instance Data.Singletons.ShowSing.ShowSing TTT.Core.Piece
instance GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Internal.SingI 'TTT.Core.PX
instance Data.Singletons.Internal.SingI 'TTT.Core.PO

module TTT.Controller
type Controller m p = forall b. CContext p b -> m (Maybe (Move b))
type Move b = Σ (N, N) (TyCon (Coord b  'Nothing))
data CContext p b
CC :: Sing b -> InPlay b -> GameState p b -> Sing p -> CContext p b
[_ccBoard] :: CContext p b -> Sing b
[_ccInPlay] :: CContext p b -> InPlay b
[_ccGameState] :: CContext p b -> GameState p b
[_ccPlayer] :: CContext p b -> Sing p

-- | Picks the first valid move in the given list
priorityController :: Applicative m => [(N, N)] -> Controller m p

-- | Picks a random move
randomController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Controller m p
validMoves :: Sing b -> Map (N, N) (Move b)
shuffledValidMoves :: PrimMonad m => Sing b -> Gen (PrimState m) -> m [((N, N), Move b)]

-- | Return a controller that, some percentage of the time, picks randomly
--   instead.
faulty :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Double -> Controller m p -> Controller m p

module TTT.Controller.Minimax

-- | This minimax implementation is "verified" in the sense that it cannot
--   make any illegal moves. We sort of get this "for free". It is also
--   verified that we will rank and sort the pieces correctly (assuming the
--   Ord instance is sound) depending on who is playing.
minimaxController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p

-- | This minimax implementation is "more verified" than the original one.
--   In addition to the verifications of the original one, we verify that
--   the search algorithm doesn't go further than the number of steps, and
--   also that at each step we are being consistent with the board and
--   possible moves.
--   
--   However, it is not a "verified AI" in that it can still make the wrong
--   choice in the end. The only thing verified really is that it
--   interprets the information it sees correctly.
minimaxController' :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p
newtype RankRes (p :: Piece)
RR :: Maybe GameOver -> RankRes
[getRR] :: RankRes -> Maybe GameOver
instance GHC.Classes.Eq (TTT.Controller.Minimax.RankRes p)
instance GHC.Show.Show (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Internal.SingI p => GHC.Classes.Ord (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Decide.SDecide k => Data.GADT.Compare.GEq Data.Singletons.Internal.Sing

module TTT.Controller.Console

-- | Will never allow any invalid moves.
consoleController :: MonadIO m => Controller m p
displayBoard :: Board -> String
