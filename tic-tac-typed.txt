-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/tic-tac-typed#readme</a>
@package tic-tac-typed
@version 0.1.0.0

module Data.Type.Nat
data N
Z :: N
S :: N -> N
type SN = (Sing :: N -> Type)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
addN :: N -> N -> N
type family AddN (a_ante :: N) (a_antf :: N) :: N
sAddN :: forall (t_aoWA :: N) (t_aoWB :: N). Sing t_aoWA -> Sing t_aoWB -> Sing (Apply (Apply AddNSym0 t_aoWA) t_aoWB :: N)
data LT :: N -> N -> Type
[LTZ] :: LT  'Z n
[LTS] :: LT n m -> LT ( 'S n) ( 'S m)
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679100014 :: N) = S t6989586621679100014
data AddNSym0 :: (~>) N ((~>) N N)
data AddNSym1 (a6989586621679100016 :: N) :: (~>) N N
type AddNSym2 (a6989586621679100016 :: N) (a6989586621679100017 :: N) = AddN a6989586621679100016 a6989586621679100017
instance GHC.Classes.Ord Data.Type.Nat.N
instance GHC.Classes.Eq Data.Type.Nat.N
instance GHC.Show.Show Data.Type.Nat.N
instance Data.Singletons.ShowSing.ShowSing Data.Type.Nat.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.Compare_6989586621679105670Sym0
instance Data.Singletons.Prelude.Ord.POrd Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.Compare_6989586621679105670Sym1 a6989586621679105668)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.ShowsPrec_6989586621679103778Sym0
instance Data.Singletons.Prelude.Show.PShow Data.Type.Nat.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.ShowsPrec_6989586621679103778Sym1 a6989586621679103775)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.ShowsPrec_6989586621679103778Sym2 a6989586621679103776 a6989586621679103775)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Nat.AddNSym1 a6989586621679100016)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.AddNSym0
instance Data.Singletons.Internal.SingI Data.Type.Nat.AddNSym0
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Nat.AddNSym1 d)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Nat.SSym0
instance Data.Singletons.Internal.SingI Data.Type.Nat.SSym0
instance Data.Singletons.Internal.SingKind Data.Type.Nat.N
instance Data.Singletons.Prelude.Show.SShow Data.Type.Nat.N => Data.Singletons.Prelude.Show.SShow Data.Type.Nat.N
instance Data.Singletons.Prelude.Ord.SOrd Data.Type.Nat.N => Data.Singletons.Prelude.Ord.SOrd Data.Type.Nat.N
instance Data.Singletons.Prelude.Eq.SEq Data.Type.Nat.N => Data.Singletons.Prelude.Eq.SEq Data.Type.Nat.N
instance Data.Singletons.Decide.SDecide Data.Type.Nat.N => Data.Singletons.Decide.SDecide Data.Type.Nat.N
instance Data.Singletons.Internal.SingI 'Data.Type.Nat.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Data.Type.Nat.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Data.Type.Nat.S)

module Data.Type.Sel

-- | A <tt><a>Sel</a> n as a</tt> is an index into a list <tt>as</tt> that
--   the <tt>n</tt>th index is <tt>a</tt>.
data Sel :: N -> [k] -> k -> Type
[SelZ] :: Sel  'Z (a : as) a
[SelS] :: Sel n as a -> Sel ( 'S n) (b : as) a
mapIx :: N -> (a_aPiH -> a_aPiH) -> [a_aPiH] -> [a_aPiH]
sMapIx :: forall a_aPiH (t_aPjZ :: N) (t_aPk0 :: (~>) a_aPiH a_aPiH) (t_aPk1 :: [a_aPiH]). Sing t_aPjZ -> Sing t_aPk0 -> Sing t_aPk1 -> Sing (Apply (Apply (Apply MapIxSym0 t_aPjZ) t_aPk0) t_aPk1 :: [a_aPiH])
type family MapIx (a_aPjB :: N) (a_aPjC :: (~>) a_aPiH a_aPiH) (a_aPjD :: [a_aPiH]) :: [a_aPiH]
setIx :: N -> a_aPiG -> [a_aPiG] -> [a_aPiG]
sSetIx :: forall a_aPiG (t_aPk5 :: N) (t_aPk6 :: a_aPiG) (t_aPk7 :: [a_aPiG]). Sing t_aPk5 -> Sing t_aPk6 -> Sing t_aPk7 -> Sing (Apply (Apply (Apply SetIxSym0 t_aPk5) t_aPk6) t_aPk7 :: [a_aPiG])
type family SetIx (a_aPjO :: N) (a_aPjP :: a_aPiG) (a_aPjQ :: [a_aPiG]) :: [a_aPiG]
overSel :: forall k n (as :: [k]) (a :: k) (f :: k ~> k). () => Sel n as a -> Sing f -> Sing as -> Sing (MapIx n f as)
setSel :: forall k n (as :: [k]) (a :: k) (b :: k). () => Sel n as a -> Sing b -> Sing as -> Sing (SetIx n b as)
listSel :: forall k n (as :: [k]). () => Sing n -> Sing as -> Decision (Σ k (TyCon (Sel n as)))
type OutOfBounds n (as :: [k]) = Refuted (Σ k (TyCon (Sel n as)))
mapIx_proof :: forall n as a f. () => Sel n as a -> Sing as -> Sel n (MapIx n f as) (f @@ a)
setIx_proof :: forall n as a b. () => Sel n as a -> Sing as -> Sel n (SetIx n b as) b
data MapIxSym0 :: forall a6989586621679206995. (~>) N ((~>) ((~>) a6989586621679206995 a6989586621679206995) ((~>) [a6989586621679206995] [a6989586621679206995]))
data MapIxSym1 (a6989586621679207051 :: N) :: forall a6989586621679206995. (~>) ((~>) a6989586621679206995 a6989586621679206995) ((~>) [a6989586621679206995] [a6989586621679206995])
data MapIxSym2 (a6989586621679207051 :: N) (a6989586621679207052 :: (~>) a6989586621679206995 a6989586621679206995) :: (~>) [a6989586621679206995] [a6989586621679206995]
type MapIxSym3 (a6989586621679207051 :: N) (a6989586621679207052 :: (~>) a6989586621679206995 a6989586621679206995) (a6989586621679207053 :: [a6989586621679206995]) = MapIx a6989586621679207051 a6989586621679207052 a6989586621679207053
data SetIxSym0 :: forall a6989586621679206994. (~>) N ((~>) a6989586621679206994 ((~>) [a6989586621679206994] [a6989586621679206994]))
data SetIxSym1 (a6989586621679207064 :: N) :: forall a6989586621679206994. (~>) a6989586621679206994 ((~>) [a6989586621679206994] [a6989586621679206994])
data SetIxSym2 (a6989586621679207064 :: N) (a6989586621679207065 :: a6989586621679206994) :: (~>) [a6989586621679206994] [a6989586621679206994]
type SetIxSym3 (a6989586621679207064 :: N) (a6989586621679207065 :: a6989586621679206994) (a6989586621679207066 :: [a6989586621679206994]) = SetIx a6989586621679207064 a6989586621679207065 a6989586621679207066
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Sel.SetIxSym0
instance Data.Singletons.Internal.SingI Data.Type.Sel.SetIxSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.SetIxSym1 a6989586621679207064)
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Sel.SetIxSym1 d)
instance forall a6989586621679206994 (a6989586621679207065 :: Data.Type.Nat.N) (a6989586621679207064 :: a6989586621679206994). Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.SetIxSym2 a6989586621679207065 a6989586621679207064)
instance forall a (d1 :: Data.Type.Nat.N) (d2 :: a). (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (Data.Type.Sel.SetIxSym2 d1 d2)
instance forall a6989586621679206995 (a6989586621679207052 :: Data.Type.Nat.N) (a6989586621679207051 :: a6989586621679206995 Data.Singletons.Internal.~> a6989586621679206995). Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.MapIxSym2 a6989586621679207052 a6989586621679207051)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Data.Type.Sel.MapIxSym1 a6989586621679207051)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Sel.MapIxSym0
instance Data.Singletons.Internal.SingI Data.Type.Sel.MapIxSym0
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (Data.Type.Sel.MapIxSym1 d)
instance forall a (d1 :: Data.Type.Nat.N) (d2 :: a Data.Singletons.Internal.~> a). (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (Data.Type.Sel.MapIxSym2 d1 d2)

module TTT.Core
data Piece
PX :: Piece
PO :: Piece
type SPiece = (Sing :: Piece -> Type)
data GameOver
GOCats :: GameOver
GOWin :: Piece -> GameOver
type SGameOver = (Sing :: GameOver -> Type)
type Board = [[Maybe Piece]]

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
altP :: Piece -> Piece
type family AltP (a_aUcB :: Piece) :: Piece
sAltP :: forall (t_aUdF :: Piece). Sing t_aUdF -> Sing (Apply AltPSym0 t_aUdF :: Piece)
lines :: [[a_aTq2]] -> [[a_aTq2]]
type family Lines (a_aUcy :: [[a_aTq2]]) :: [[a_aTq2]]
sLines :: forall a_aTq2 (t_aUdD :: [[a_aTq2]]). Sing t_aUdD -> Sing (Apply LinesSym0 t_aUdD :: [[a_aTq2]])
emptyBoard :: Board
type family EmptyBoard :: [[Maybe Piece]]
sEmptyBoard :: Sing (EmptyBoardSym0 :: [[Maybe Piece]])
placeBoard :: N -> N -> Piece -> Board -> Board
type family PlaceBoard (a_aUcg :: N) (a_aUch :: N) (a_aUci :: Piece) (a_aUcj :: [[Maybe Piece]]) :: [[Maybe Piece]]
sPlaceBoard :: forall (t_aUdt :: N) (t_aUdu :: N) (t_aUdv :: Piece) (t_aUdw :: [[Maybe Piece]]). Sing t_aUdt -> Sing t_aUdu -> Sing t_aUdv -> Sing t_aUdw -> Sing (Apply (Apply (Apply (Apply PlaceBoardSym0 t_aUdt) t_aUdu) t_aUdv) t_aUdw :: [[Maybe Piece]])

-- | Convert a parameterized predicate into a predicate on the parameter
--   
--   A <tt><a>Found</a> p</tt> is a predicate on <tt>p :: <a>ParamPred</a>
--   k v</tt> that tests a <tt>k</tt> for the fact that there exists a
--   <tt>v</tt> where <tt><a>ParamPred</a> k v</tt> is satisfied.
--   
--   Meant to be used to allow one to write <a>Provable</a> and
--   <a>Decidable</a> instances for <tt><a>Found</a> p</tt>, for a given
--   <a>ParamPred</a> <tt>p</tt>.
--   
--   For some context, an instance of <tt><a>Provable</a> (<a>Found</a>
--   P)</tt>, where <tt>P :: <a>ParamPred</a> k v</tt>, means that for any
--   input <tt>x :: k</tt>, we can always find a <tt>y :: v</tt> such that
--   we have <tt>P x </tt><tt> y</tt>.
--   
--   In the language of quantifiers, it means that forall <tt>x :: k</tt>,
--   there exists a <tt>y :: v</tt> such that <tt>P x </tt><tt> y</tt>.
--   
--   For an instance of <tt><a>Decidable</a> (<a>Found</a> P)</tt>, it
--   means that for all <tt>x :: k</tt>, we can prove or disprove the fact
--   that there exists a <tt>y :: v</tt> such that <tt>P x </tt><tt>
--   y</tt>.
data Found (a :: ParamPred k v) (b :: TyFun k Type) :: forall v k. () => ParamPred k v -> TyFun k Type -> Type

-- | Predicate that a board is won by a given player
type Winner = (PPMap LinesSym0 (AnyMatch [] LineWon) :: ParamPred Board Piece)

-- | Predicate that all spots have been played (cats game).
--   
--   <pre>
--   <a>Cats</a> :: <a>Predicate</a> <a>Board</a>
--   </pre>
type Cats = (All [] (All [] (Any Maybe Evident)) :: Predicate Board)

-- | Witness that a game is in a specific mode.
--   
--   Generate using <tt>Taken</tt> for 'Found GameModeFOr'.
data GameMode :: Board -> Maybe GameOver -> Type
[GMVictory] :: (Winner b @@ p) -> GameMode b ( 'Just ( 'GOWin p))
[GMCats] :: (Not (Found Winner) @@ b) -> (Cats @@ b) -> GameMode b ( 'Just  'GOCats)
[GMInPlay] :: (Not (Found Winner) @@ b) -> (Not Cats @@ b) -> GameMode b  'Nothing
data GameModeFor :: ParamPred Board (Maybe GameOver)

-- | Current board and currently expected player.
--   
--   Can only be constructed by appending valid moves onto a known valid
--   game state.
data GameState :: Piece -> Board -> Type
[GSStart] :: GameState  'PX EmptyBoard
[GSUpdate] :: InPlay b1 -> Update ij p b1 b2 -> GameState p b1 -> GameState (AltP p) b2

-- | Represents a legal update to a board (in-bounds, and does not
--   overwrite a played piece)
data Update :: (N, N) -> Piece -> Board -> Board -> Type
[Update] :: Coord b  'Nothing '(i, j) -> Sing p -> Update '(i, j) p b (PlaceBoard i j p b)

-- | Represents a board and coordinate with the current item at position on
--   the board.
data Coord :: Board -> Maybe Piece -> (N, N) -> Type
[Coord] :: Sel i b row -> Sel j row p -> Coord b p '(i, j)
type InPlay b = GameMode b  'Nothing

-- | The empty board is in-play.
startInPlay :: InPlay EmptyBoard

-- | Type-safe "play".
play :: forall b i j row p. () => InPlay b -> Sel i b row -> Sel j row  'Nothing -> Sing p -> GameState p b -> GameState (AltP p) (PlaceBoard i j p b)

-- | Potential results of <a>pick</a>: A verified move, or one of many
--   failures (with proof of failures)
data Pick :: N -> N -> Board -> Type
[PickValid] :: Sel i b row -> Sel j row  'Nothing -> Pick i j b
[PickPlayed] :: Sel i b row -> Sel j row ( 'Just p) -> Sing p -> Pick i j b
[PickOoBX] :: OutOfBounds i b -> Pick i j b
[PickOoBY] :: Sel i b row -> OutOfBounds j row -> Pick i j b

-- | Validate a pick from given coordinates on a board
pick :: Sing i -> Sing j -> Sing b -> Pick i j b
data GOWinSym0 :: (~>) Piece GameOver
type GOWinSym1 (t6989586621679225814 :: Piece) = GOWin t6989586621679225814
type GOCatsSym0 = GOCats
type BoardSym0 = Board
data AltPSym0 :: (~>) Piece Piece
type AltPSym1 (a6989586621679225837 :: Piece) = AltP a6989586621679225837
data LinesSym0 :: forall a6989586621679222826. (~>) [[a6989586621679222826]] [[a6989586621679222826]]
type LinesSym1 (a6989586621679225834 :: [[a6989586621679222826]]) = Lines a6989586621679225834
type EmptyBoardSym0 = EmptyBoard
data PlaceBoardSym0 :: (~>) N ((~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])))
data PlaceBoardSym1 (a6989586621679225816 :: N) :: (~>) N ((~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]]))
data PlaceBoardSym2 (a6989586621679225816 :: N) (a6989586621679225817 :: N) :: (~>) Piece ((~>) [[Maybe Piece]] [[Maybe Piece]])
data PlaceBoardSym3 (a6989586621679225816 :: N) (a6989586621679225817 :: N) (a6989586621679225818 :: Piece) :: (~>) [[Maybe Piece]] [[Maybe Piece]]
type PlaceBoardSym4 (a6989586621679225816 :: N) (a6989586621679225817 :: N) (a6989586621679225818 :: Piece) (a6989586621679225819 :: [[Maybe Piece]]) = PlaceBoard a6989586621679225816 a6989586621679225817 a6989586621679225818 a6989586621679225819
instance GHC.Classes.Eq TTT.Core.GameOver
instance GHC.Show.Show TTT.Core.GameOver
instance GHC.Classes.Eq TTT.Core.Piece
instance GHC.Show.Show TTT.Core.Piece
instance GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.ShowSing.ShowSing TTT.Core.Piece => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found TTT.Core.GameModeFor)
instance Data.Type.Predicate.Provable (Data.Type.Predicate.Param.Found TTT.Core.GameModeFor)
instance Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found TTT.Core.LineWon)
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.GameOver
instance Data.Singletons.Prelude.Eq.PEq TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679225876Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.GameOver
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679225876Sym1 a6989586621679225873)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679225876Sym2 a6989586621679225874 a6989586621679225873)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.ShowsPrec_6989586621679225854Sym0
instance Data.Singletons.Prelude.Show.PShow TTT.Core.Piece
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679225854Sym1 a6989586621679225851)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.ShowsPrec_6989586621679225854Sym2 a6989586621679225852 a6989586621679225851)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.AltPSym0
instance Data.Singletons.Internal.SingI TTT.Core.AltPSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.LinesSym0
instance Data.Singletons.Internal.SingI TTT.Core.LinesSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.DiagonalSym0
instance Data.Singletons.Internal.SingI TTT.Core.DiagonalSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.PlaceBoardSym0
instance Data.Singletons.Internal.SingI TTT.Core.PlaceBoardSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym1 a6989586621679225816)
instance Data.Singletons.Internal.SingI d => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym1 d)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym2 a6989586621679225817 a6989586621679225816)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym2 d1 d2)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (TTT.Core.PlaceBoardSym3 a6989586621679225818 a6989586621679225817 a6989586621679225816)
instance (Data.Singletons.Internal.SingI d1, Data.Singletons.Internal.SingI d2, Data.Singletons.Internal.SingI d3) => Data.Singletons.Internal.SingI (TTT.Core.PlaceBoardSym3 d1 d2 d3)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TTT.Core.GOWinSym0
instance Data.Singletons.Internal.SingI TTT.Core.GOWinSym0
instance Data.Singletons.Internal.SingKind TTT.Core.GameOver
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece => Data.Singletons.Prelude.Show.SShow TTT.Core.GameOver
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece => Data.Singletons.Prelude.Eq.SEq TTT.Core.GameOver
instance Data.Singletons.Decide.SDecide TTT.Core.Piece => Data.Singletons.Decide.SDecide TTT.Core.GameOver
instance Data.Singletons.Internal.SingI 'TTT.Core.GOCats
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('TTT.Core.GOWin n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'TTT.Core.GOWin)
instance Data.Singletons.Internal.SingKind TTT.Core.Piece
instance Data.Singletons.Prelude.Show.SShow TTT.Core.Piece
instance Data.Singletons.Prelude.Eq.SEq TTT.Core.Piece
instance Data.Singletons.Decide.SDecide TTT.Core.Piece
instance Data.Singletons.Internal.SingI 'TTT.Core.PX
instance Data.Singletons.Internal.SingI 'TTT.Core.PO

module TTT.Controller
type Controller m p = forall b. CContext p b -> m (Maybe (Move b))
type Move b = Σ (N, N) (TyCon (Coord b  'Nothing))
data CContext p b
CC :: Sing b -> InPlay b -> GameState p b -> Sing p -> CContext p b
[_ccBoard] :: CContext p b -> Sing b
[_ccInPlay] :: CContext p b -> InPlay b
[_ccGameState] :: CContext p b -> GameState p b
[_ccPlayer] :: CContext p b -> Sing p

-- | Picks the first valid move in the given list
priorityController :: Applicative m => [(N, N)] -> Controller m p

-- | Picks a random move
randomController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Controller m p
validMoves :: Sing b -> Map (N, N) (Move b)
shuffledValidMoves :: PrimMonad m => Sing b -> Gen (PrimState m) -> m [((N, N), Move b)]

-- | Return a controller that, some percentage of the time, picks randomly
--   instead.
faulty :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => Double -> Controller m p -> Controller m p

module TTT.Controller.Minimax

-- | This minimax implementation is "verified" in the sense that it cannot
--   make any illegal moves. We sort of get this "for free". It is also
--   verified that we will rank and sort the pieces correctly (assuming the
--   Ord instance is sound) depending on who is playing.
minimaxController :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p

-- | This minimax implementation is "more verified" than the original one.
--   In addition to the verifications of the original one, we verify that
--   the search algorithm doesn't go further than the number of steps, and
--   also that at each step we are being consistent with the board and
--   possible moves.
--   
--   However, it is not a "verified AI" in that it can still make the wrong
--   choice in the end. The only thing verified really is that it
--   interprets the information it sees correctly.
minimaxController' :: (PrimMonad m, MonadReader (Gen (PrimState m)) m) => N -> Controller m p
newtype RankRes (p :: Piece)
RR :: Maybe GameOver -> RankRes
[getRR] :: RankRes -> Maybe GameOver
instance GHC.Classes.Eq (TTT.Controller.Minimax.RankRes p)
instance GHC.Show.Show (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Internal.SingI p => GHC.Classes.Ord (TTT.Controller.Minimax.RankRes p)
instance Data.Singletons.Decide.SDecide k => Data.GADT.Compare.GEq Data.Singletons.Internal.Sing

module TTT.Controller.Console

-- | Will never allow any invalid moves.
consoleController :: MonadIO m => Controller m p
displayBoard :: Board -> String
